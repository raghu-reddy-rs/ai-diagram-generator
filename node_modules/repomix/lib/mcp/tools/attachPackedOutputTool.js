var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import fs from 'node:fs/promises';
import path from 'node:path';
import { z } from 'zod';
import { buildMcpToolErrorResponse, convertErrorToJson, formatPackToolResponse, } from './mcpToolRuntime.js';
/**
 * Schema for the attach packed output tool input
 */
const attachPackedOutputInputSchema = z.object({
    path: z
        .string()
        .describe('Path to a directory containing repomix-output.xml or direct path to a packed repository XML file'),
    topFilesLength: z
        .number()
        .optional()
        .default(10)
        .describe('Number of largest files by size to display in the metrics summary (default: 10)'),
});
/**
 * Schema for the attach packed output tool output
 */
const attachPackedOutputOutputSchema = z.object({
    description: z.string().describe('Human-readable description of the attached output'),
    result: z.string().describe('JSON string containing detailed metrics and file information'),
    directoryStructure: z.string().describe('Tree structure extracted from the packed output'),
    outputId: z.string().describe('Unique identifier for accessing the packed content'),
    outputFilePath: z.string().describe('File path to the attached output file'),
    totalFiles: z.number().describe('Total number of files in the packed output'),
    totalTokens: z.number().describe('Total token count of the content'),
});
/**
 * Resolves the path to a repomix output file
 * @param inputPath Path to a directory containing repomix-output.xml or direct path to an XML file
 * @returns The resolved path to the repomix output file
 * @throws Error if the file doesn't exist or isn't a valid XML file
 */
function resolveOutputFilePath(inputPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const stats = yield fs.stat(inputPath);
            if (stats.isDirectory()) {
                // If it's a directory, look for repomix-output.xml inside
                const outputFilePath = path.join(inputPath, 'repomix-output.xml');
                yield fs.access(outputFilePath); // Will throw if file doesn't exist
                return outputFilePath;
            }
            // If it's a file, check if it's an XML file
            if (!inputPath.toLowerCase().endsWith('.xml')) {
                throw new Error('The provided file is not an XML file. Only XML files are supported.');
            }
            return inputPath;
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('ENOENT')) {
                throw new Error(`File or directory not found for path: ${inputPath}`, { cause: error });
            }
            throw error;
        }
    });
}
/**
 * Extract file paths and character counts from a repomix output XML file
 * @param content The content of the repomix output XML file
 * @returns An object containing an array of file paths and a record of file paths to character counts
 */
function extractFileMetrics(content) {
    const filePaths = [];
    const fileCharCounts = {};
    const fileRegex = /<file path="([^"]+)">([\s\S]*?)<\/file>/g;
    let match;
    while (true) {
        match = fileRegex.exec(content);
        if (!match) {
            break;
        }
        const filePath = match[1];
        const fileContent = match[2];
        filePaths.push(filePath);
        fileCharCounts[filePath] = fileContent.length;
    }
    return { filePaths, fileCharCounts };
}
/**
 * Create processed files from file paths
 * @param filePaths Array of file paths
 * @param charCounts Record of file paths to character counts
 * @returns Array of ProcessedFile objects
 */
function createProcessedFiles(filePaths, charCounts) {
    return filePaths.map((path) => ({
        path,
        content: ''.padEnd(charCounts[path]), // Create a string of the appropriate length
    }));
}
/**
 * Register the attach packed output tool with the MCP server
 */
export const registerAttachPackedOutputTool = (mcpServer) => {
    mcpServer.registerTool('attach_packed_output', {
        title: 'Attach Packed Output',
        description: `Attach an existing Repomix packed output file for AI analysis.
This tool accepts either a directory containing a repomix-output.xml file or a direct path to an XML file.
Calling the tool again with the same file path will refresh the content if the file has been updated.
It will return in that case a new output ID and the updated content.`,
        inputSchema: attachPackedOutputInputSchema.shape,
        outputSchema: attachPackedOutputOutputSchema.shape,
        annotations: {
            readOnlyHint: true,
            destructiveHint: false,
            idempotentHint: true,
            openWorldHint: false,
        },
    }, (_a) => __awaiter(void 0, [_a], void 0, function* ({ path: inputPath, topFilesLength }) {
        try {
            // Resolve the path to the repomix output file
            const outputFilePath = yield resolveOutputFilePath(inputPath);
            // Read the file content
            const content = yield fs.readFile(outputFilePath, 'utf8');
            // Extract file paths and character counts from the XML content
            const { filePaths, fileCharCounts } = extractFileMetrics(content);
            // Calculate metrics
            const totalCharacters = Object.values(fileCharCounts).reduce((sum, count) => sum + count, 0);
            const totalTokens = Math.floor(totalCharacters / 4); // Rough estimate of tokens
            // Create approximate token counts (roughly 4 chars per token)
            const fileTokenCounts = {};
            for (const [filePath, charCount] of Object.entries(fileCharCounts)) {
                fileTokenCounts[filePath] = Math.floor(charCount / 4);
            }
            // Create processed files for the metrics
            const processedFiles = createProcessedFiles(filePaths, fileCharCounts);
            // Create metrics object similar to what packResult would provide
            const packResult = {
                totalFiles: filePaths.length,
                totalCharacters,
                totalTokens,
                safeFilePaths: filePaths,
                fileCharCounts,
                fileTokenCounts,
                processedFiles,
            };
            // Create context object
            const context = {
                // Extract directory or repository name from the path
                directory: path.basename(path.dirname(outputFilePath)),
            };
            return yield formatPackToolResponse(context, packResult, outputFilePath, topFilesLength);
        }
        catch (error) {
            return buildMcpToolErrorResponse(convertErrorToJson(error));
        }
    }));
};
//# sourceMappingURL=attachPackedOutputTool.js.map