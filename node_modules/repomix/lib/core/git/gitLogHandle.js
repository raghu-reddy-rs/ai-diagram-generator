var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { RepomixError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';
import { execGitLog } from './gitCommand.js';
import { isGitRepository } from './gitRepositoryHandle.js';
// Null character used as record separator in git log output for robust parsing
// This ensures commits are split correctly even when commit messages contain newlines
export const GIT_LOG_RECORD_SEPARATOR = '\x00';
// Git format string for null character separator
// Git expects %x00 format in pretty format strings
export const GIT_LOG_FORMAT_SEPARATOR = '%x00';
const parseGitLog = (rawLogOutput, recordSeparator = GIT_LOG_RECORD_SEPARATOR) => {
    if (!rawLogOutput.trim()) {
        return [];
    }
    const commits = [];
    // Split by record separator used in git log output
    // This is more robust than splitting by double newlines, as commit messages may contain newlines
    const logEntries = rawLogOutput.split(recordSeparator).filter(Boolean);
    for (const entry of logEntries) {
        // Split on both \n and \r\n to handle different line ending formats across platforms
        const lines = entry.split(/\r?\n/).filter((line) => line.trim() !== '');
        if (lines.length === 0)
            continue;
        // First line contains date and message separated by |
        const firstLine = lines[0];
        const separatorIndex = firstLine.indexOf('|');
        if (separatorIndex === -1)
            continue;
        const date = firstLine.substring(0, separatorIndex);
        const message = firstLine.substring(separatorIndex + 1);
        // Remaining lines are file paths
        const files = lines.slice(1).filter((line) => line.trim() !== '');
        commits.push({
            date,
            message,
            files,
        });
    }
    return commits;
};
export const getGitLog = (directory_1, maxCommits_1, ...args_1) => __awaiter(void 0, [directory_1, maxCommits_1, ...args_1], void 0, function* (directory, maxCommits, deps = {
    execGitLog,
    isGitRepository,
}) {
    if (!(yield deps.isGitRepository(directory))) {
        logger.trace(`Directory ${directory} is not a git repository`);
        return '';
    }
    try {
        return yield deps.execGitLog(directory, maxCommits, GIT_LOG_FORMAT_SEPARATOR);
    }
    catch (error) {
        logger.trace('Failed to get git log:', error.message);
        throw error;
    }
});
export const getGitLogs = (rootDirs_1, config_1, ...args_1) => __awaiter(void 0, [rootDirs_1, config_1, ...args_1], void 0, function* (rootDirs, config, deps = {
    getGitLog,
}) {
    var _a, _b;
    // Get git logs if enabled
    let gitLogResult;
    if ((_a = config.output.git) === null || _a === void 0 ? void 0 : _a.includeLogs) {
        try {
            // Use the first directory as the git repository root
            // Usually this would be the root of the project
            const gitRoot = rootDirs[0] || config.cwd;
            const maxCommits = ((_b = config.output.git) === null || _b === void 0 ? void 0 : _b.includeLogsCount) || 50;
            const logContent = yield deps.getGitLog(gitRoot, maxCommits);
            // Parse the raw log content into structured commits
            const commits = parseGitLog(logContent);
            gitLogResult = {
                logContent,
                commits,
            };
        }
        catch (error) {
            throw new RepomixError(`Failed to get git logs: ${error.message}`, { cause: error });
        }
    }
    return gitLogResult;
});
//# sourceMappingURL=gitLogHandle.js.map