var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { RepomixError } from '../../shared/errorHandle.js';
import { logger } from '../../shared/logger.js';
import { execGitDiff } from './gitCommand.js';
import { isGitRepository } from './gitRepositoryHandle.js';
export const getWorkTreeDiff = (directory_1, ...args_1) => __awaiter(void 0, [directory_1, ...args_1], void 0, function* (directory, deps = {
    execGitDiff,
    isGitRepository,
}) {
    return getDiff(directory, [], deps);
});
export const getStagedDiff = (directory_1, ...args_1) => __awaiter(void 0, [directory_1, ...args_1], void 0, function* (directory, deps = {
    execGitDiff,
    isGitRepository,
}) {
    return getDiff(directory, ['--cached'], deps);
});
/**
 * Helper function to get git diff with common repository check and error handling
 */
const getDiff = (directory_1, options_1, ...args_1) => __awaiter(void 0, [directory_1, options_1, ...args_1], void 0, function* (directory, options, deps = {
    execGitDiff,
    isGitRepository,
}) {
    try {
        // Check if the directory is a git repository
        const isGitRepo = yield deps.isGitRepository(directory);
        if (!isGitRepo) {
            logger.trace('Not a git repository, skipping diff generation');
            return '';
        }
        // Get the diff with provided options
        const result = yield deps.execGitDiff(directory, options);
        return result;
    }
    catch (error) {
        logger.trace('Failed to get git diff:', error.message);
        return '';
    }
});
export const getGitDiffs = (rootDirs_1, config_1, ...args_1) => __awaiter(void 0, [rootDirs_1, config_1, ...args_1], void 0, function* (rootDirs, config, deps = {
    getWorkTreeDiff,
    getStagedDiff,
}) {
    var _a;
    // Get git diffs if enabled
    let gitDiffResult;
    if ((_a = config.output.git) === null || _a === void 0 ? void 0 : _a.includeDiffs) {
        try {
            // Use the first directory as the git repository root
            // Usually this would be the root of the project
            const gitRoot = rootDirs[0] || config.cwd;
            const [workTreeDiffContent, stagedDiffContent] = yield Promise.all([
                deps.getWorkTreeDiff(gitRoot),
                deps.getStagedDiff(gitRoot),
            ]);
            gitDiffResult = {
                workTreeDiffContent,
                stagedDiffContent,
            };
        }
        catch (error) {
            if (error instanceof Error) {
                throw new RepomixError(`Failed to get git diffs: ${error.message}`);
            }
        }
    }
    return gitDiffResult;
});
//# sourceMappingURL=gitDiffHandle.js.map