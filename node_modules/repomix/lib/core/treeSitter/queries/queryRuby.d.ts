export declare const queryRuby = "\n(comment) @comment\n\n; Import statements\n(call\n  (identifier) @name.reference.module) @definition.import\n\n; Method definitions\n\n(\n  (comment)* @doc\n  .\n  [\n    (method\n      name: (_) @name.definition.method) @definition.method\n    (singleton_method\n      name: (_) @name.definition.method) @definition.method\n  ]\n  (#strip! @doc \"^#\\s*\")\n  (#select-adjacent! @doc @definition.method)\n)\n\n(alias\n  name: (_) @name.definition.method) @definition.method\n\n(setter\n  (identifier) @ignore)\n\n; Class definitions\n\n(\n  (comment)* @doc\n  .\n  [\n    (class\n      name: [\n        (constant) @name.definition.class\n        (scope_resolution\n          name: (_) @name.definition.class)\n      ]) @definition.class\n    (singleton_class\n      value: [\n        (constant) @name.definition.class\n        (scope_resolution\n          name: (_) @name.definition.class)\n      ]) @definition.class\n  ]\n  (#strip! @doc \"^#\\s*\")\n  (#select-adjacent! @doc @definition.class)\n)\n\n; Module definitions\n\n(\n  (module\n    name: [\n      (constant) @name.definition.module\n      (scope_resolution\n        name: (_) @name.definition.module)\n    ]) @definition.module\n)\n\n; Calls\n\n(call method: (identifier) @name.reference.call) @reference.call\n\n(\n  [(identifier) (constant)] @name.reference.call @reference.call\n  (#is-not? local)\n  (#not-match? @name.reference.call \"^(lambda|load|require|require_relative|__FILE__|__LINE__)$\")\n)\n";
//# sourceMappingURL=queryRuby.d.ts.map