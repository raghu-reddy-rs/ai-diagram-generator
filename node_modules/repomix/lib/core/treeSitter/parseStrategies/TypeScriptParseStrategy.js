var CaptureType;
(function (CaptureType) {
    CaptureType["Comment"] = "comment";
    CaptureType["Interface"] = "definition.interface";
    CaptureType["Type"] = "definition.type";
    CaptureType["Enum"] = "definition.enum";
    CaptureType["Class"] = "definition.class";
    CaptureType["Import"] = "definition.import";
    CaptureType["Function"] = "definition.function";
    CaptureType["Method"] = "definition.method";
    CaptureType["Property"] = "definition.property";
})(CaptureType || (CaptureType = {}));
export class TypeScriptParseStrategy {
    parseCapture(capture, lines, processedChunks, _context) {
        const { node, name } = capture;
        const startRow = node.startPosition.row;
        const endRow = node.endPosition.row;
        if (!lines[startRow]) {
            return null;
        }
        const captureTypes = this.getCaptureType(name);
        // Function capture
        if (captureTypes.has(CaptureType.Function) || captureTypes.has(CaptureType.Method)) {
            return this.parseFunctionDefinition(lines, startRow, endRow, processedChunks).content;
        }
        // Class capture
        if (captureTypes.has(CaptureType.Class)) {
            return this.parseClassDefinition(lines, startRow, endRow, processedChunks).content;
        }
        // Type definition or import capture
        if (captureTypes.has(CaptureType.Interface) ||
            captureTypes.has(CaptureType.Type) ||
            captureTypes.has(CaptureType.Enum) ||
            captureTypes.has(CaptureType.Import)) {
            return this.parseTypeOrImport(lines, startRow, endRow, processedChunks).content;
        }
        // Comment capture
        if (captureTypes.has(CaptureType.Comment)) {
            return lines
                .slice(startRow, endRow + 1)
                .join('\n')
                .trim();
        }
        return null;
    }
    getFunctionName(lines, startRow) {
        var _a;
        const line = lines[startRow];
        const match = line.match(TypeScriptParseStrategy.FUNCTION_NAME_PATTERN);
        return (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : null;
    }
    getCaptureType(name) {
        const types = new Set();
        for (const type of Object.values(CaptureType)) {
            if (name.includes(type)) {
                types.add(type);
            }
        }
        return types;
    }
    parseFunctionDefinition(lines, startRow, endRow, processedChunks) {
        const functionName = this.getFunctionName(lines, startRow);
        if (functionName && processedChunks.has(`func:${functionName}`)) {
            return { content: null };
        }
        const signatureEndRow = this.findSignatureEnd(lines, startRow, endRow);
        const selectedLines = lines.slice(startRow, signatureEndRow + 1);
        const cleanedSignature = this.cleanFunctionSignature(selectedLines);
        if (processedChunks.has(cleanedSignature)) {
            return { content: null };
        }
        processedChunks.add(cleanedSignature);
        if (functionName) {
            processedChunks.add(`func:${functionName}`);
        }
        return { content: cleanedSignature };
    }
    findSignatureEnd(lines, startRow, endRow) {
        for (let i = startRow; i <= endRow; i++) {
            const line = lines[i].trim();
            if (line.includes(')') && (line.endsWith('{') || line.endsWith('=>') || line.endsWith(';'))) {
                return i;
            }
        }
        return startRow;
    }
    cleanFunctionSignature(lines) {
        const result = [...lines];
        const lastLineIndex = result.length - 1;
        const lastLine = result[lastLineIndex];
        if (lastLine) {
            if (lastLine.includes('{')) {
                result[lastLineIndex] = lastLine.substring(0, lastLine.indexOf('{')).trim();
            }
            else if (lastLine.includes('=>')) {
                result[lastLineIndex] = lastLine.substring(0, lastLine.indexOf('=>')).trim();
            }
        }
        return result.join('\n').trim();
    }
    parseClassDefinition(lines, startRow, endRow, processedChunks) {
        const selectedLines = [lines[startRow]];
        if (startRow + 1 <= endRow) {
            const nextLine = lines[startRow + 1].trim();
            if (nextLine.includes('extends') || nextLine.includes('implements')) {
                selectedLines.push(nextLine);
            }
        }
        const cleanedLines = selectedLines.map((line) => line.replace(/\{.*$/, '').trim());
        const definition = cleanedLines.join('\n').trim();
        if (processedChunks.has(definition)) {
            return { content: null };
        }
        processedChunks.add(definition);
        return { content: definition };
    }
    parseTypeOrImport(lines, startRow, endRow, processedChunks) {
        const selectedLines = lines.slice(startRow, endRow + 1);
        const definition = selectedLines.join('\n').trim();
        if (processedChunks.has(definition)) {
            return { content: null };
        }
        processedChunks.add(definition);
        return { content: definition };
    }
}
TypeScriptParseStrategy.FUNCTION_NAME_PATTERN = /(?:export\s+)?(?:const|let|var)\s+([a-zA-Z0-9_$]+)\s*=/;
//# sourceMappingURL=TypeScriptParseStrategy.js.map