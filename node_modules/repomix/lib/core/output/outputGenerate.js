var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import fs from 'node:fs/promises';
import path from 'node:path';
import { XMLBuilder } from 'fast-xml-parser';
import Handlebars from 'handlebars';
import { RepomixError } from '../../shared/errorHandle.js';
import { searchFiles } from '../file/fileSearch.js';
import { generateTreeString } from '../file/fileTreeGenerate.js';
import { sortOutputFiles } from './outputSort.js';
import { generateHeader, generateSummaryFileFormat, generateSummaryFileFormatJson, generateSummaryNotes, generateSummaryPurpose, generateSummaryUsageGuidelines, } from './outputStyleDecorate.js';
import { getMarkdownTemplate } from './outputStyles/markdownStyle.js';
import { getPlainTemplate } from './outputStyles/plainStyle.js';
import { getXmlTemplate } from './outputStyles/xmlStyle.js';
const calculateMarkdownDelimiter = (files) => {
    const maxBackticks = files
        .flatMap((file) => { var _a; return (_a = file.content.match(/`+/g)) !== null && _a !== void 0 ? _a : []; })
        .reduce((max, match) => Math.max(max, match.length), 0);
    return '`'.repeat(Math.max(3, maxBackticks + 1));
};
const createRenderContext = (outputGeneratorContext) => {
    var _a, _b, _c, _d, _e, _f;
    return {
        generationHeader: generateHeader(outputGeneratorContext.config, outputGeneratorContext.generationDate),
        summaryPurpose: generateSummaryPurpose(outputGeneratorContext.config),
        summaryFileFormat: generateSummaryFileFormat(),
        summaryUsageGuidelines: generateSummaryUsageGuidelines(outputGeneratorContext.config, outputGeneratorContext.instruction),
        summaryNotes: generateSummaryNotes(outputGeneratorContext.config),
        headerText: outputGeneratorContext.config.output.headerText,
        instruction: outputGeneratorContext.instruction,
        treeString: outputGeneratorContext.treeString,
        processedFiles: outputGeneratorContext.processedFiles,
        fileSummaryEnabled: outputGeneratorContext.config.output.fileSummary,
        directoryStructureEnabled: outputGeneratorContext.config.output.directoryStructure,
        filesEnabled: outputGeneratorContext.config.output.files,
        escapeFileContent: outputGeneratorContext.config.output.parsableStyle,
        markdownCodeBlockDelimiter: calculateMarkdownDelimiter(outputGeneratorContext.processedFiles),
        gitDiffEnabled: (_a = outputGeneratorContext.config.output.git) === null || _a === void 0 ? void 0 : _a.includeDiffs,
        gitDiffWorkTree: (_b = outputGeneratorContext.gitDiffResult) === null || _b === void 0 ? void 0 : _b.workTreeDiffContent,
        gitDiffStaged: (_c = outputGeneratorContext.gitDiffResult) === null || _c === void 0 ? void 0 : _c.stagedDiffContent,
        gitLogEnabled: (_d = outputGeneratorContext.config.output.git) === null || _d === void 0 ? void 0 : _d.includeLogs,
        gitLogContent: (_e = outputGeneratorContext.gitLogResult) === null || _e === void 0 ? void 0 : _e.logContent,
        gitLogCommits: (_f = outputGeneratorContext.gitLogResult) === null || _f === void 0 ? void 0 : _f.commits,
    };
};
const generateParsableXmlOutput = (renderContext) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const xmlBuilder = new XMLBuilder({ ignoreAttributes: false });
    const xmlDocument = {
        repomix: {
            file_summary: renderContext.fileSummaryEnabled
                ? {
                    '#text': renderContext.generationHeader,
                    purpose: renderContext.summaryPurpose,
                    file_format: `${renderContext.summaryFileFormat}
5. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file`,
                    usage_guidelines: renderContext.summaryUsageGuidelines,
                    notes: renderContext.summaryNotes,
                }
                : undefined,
            user_provided_header: renderContext.headerText,
            directory_structure: renderContext.directoryStructureEnabled ? renderContext.treeString : undefined,
            files: renderContext.filesEnabled
                ? {
                    '#text': "This section contains the contents of the repository's files.",
                    file: renderContext.processedFiles.map((file) => ({
                        '#text': file.content,
                        '@_path': file.path,
                    })),
                }
                : undefined,
            git_diffs: renderContext.gitDiffEnabled
                ? {
                    git_diff_work_tree: renderContext.gitDiffWorkTree,
                    git_diff_staged: renderContext.gitDiffStaged,
                }
                : undefined,
            git_logs: renderContext.gitLogEnabled
                ? {
                    git_log_commit: (_a = renderContext.gitLogCommits) === null || _a === void 0 ? void 0 : _a.map((commit) => ({
                        date: commit.date,
                        message: commit.message,
                        files: commit.files.map((file) => ({ '#text': file })),
                    })),
                }
                : undefined,
            instruction: renderContext.instruction ? renderContext.instruction : undefined,
        },
    };
    try {
        return xmlBuilder.build(xmlDocument);
    }
    catch (error) {
        throw new RepomixError(`Failed to generate XML output: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? { cause: error } : undefined);
    }
});
const generateParsableJsonOutput = (renderContext) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const jsonDocument = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (renderContext.fileSummaryEnabled && {
        fileSummary: {
            generationHeader: renderContext.generationHeader,
            purpose: renderContext.summaryPurpose,
            fileFormat: generateSummaryFileFormatJson(),
            usageGuidelines: renderContext.summaryUsageGuidelines,
            notes: renderContext.summaryNotes,
        },
    })), (renderContext.headerText && {
        userProvidedHeader: renderContext.headerText,
    })), (renderContext.directoryStructureEnabled && {
        directoryStructure: renderContext.treeString,
    })), (renderContext.filesEnabled && {
        files: renderContext.processedFiles.reduce((acc, file) => {
            acc[file.path] = file.content;
            return acc;
        }, {}),
    })), (renderContext.gitDiffEnabled && {
        gitDiffs: {
            workTree: renderContext.gitDiffWorkTree,
            staged: renderContext.gitDiffStaged,
        },
    })), (renderContext.gitLogEnabled && {
        gitLogs: (_a = renderContext.gitLogCommits) === null || _a === void 0 ? void 0 : _a.map((commit) => ({
            date: commit.date,
            message: commit.message,
            files: commit.files,
        })),
    })), (renderContext.instruction && {
        instruction: renderContext.instruction,
    }));
    try {
        return JSON.stringify(jsonDocument, null, 2);
    }
    catch (error) {
        throw new RepomixError(`Failed to generate JSON output: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? { cause: error } : undefined);
    }
});
const generateHandlebarOutput = (config, renderContext, processedFiles) => __awaiter(void 0, void 0, void 0, function* () {
    let template;
    switch (config.output.style) {
        case 'xml':
            template = getXmlTemplate();
            break;
        case 'markdown':
            template = getMarkdownTemplate();
            break;
        case 'plain':
            template = getPlainTemplate();
            break;
        default:
            throw new RepomixError(`Unsupported output style for handlebars template: ${config.output.style}`);
    }
    try {
        const compiledTemplate = Handlebars.compile(template);
        return `${compiledTemplate(renderContext).trim()}\n`;
    }
    catch (error) {
        if (error instanceof RangeError && error.message === 'Invalid string length') {
            let largeFilesInfo = '';
            if (processedFiles && processedFiles.length > 0) {
                const topFiles = processedFiles
                    .sort((a, b) => b.content.length - a.content.length)
                    .slice(0, 5)
                    .map((f) => `  - ${f.path} (${(f.content.length / 1024 / 1024).toFixed(1)} MB)`)
                    .join('\n');
                largeFilesInfo = `\n\nLargest files in this repository:\n${topFiles}`;
            }
            throw new RepomixError(`Output size exceeds JavaScript string limit. The repository contains files that are too large to process.
Please try:
  - Use --ignore to exclude large files (e.g., --ignore "docs/**" or --ignore "*.html")
  - Use --include to process only specific files
  - Process smaller portions of the repository at a time${largeFilesInfo}`, { cause: error });
        }
        throw new RepomixError(`Failed to compile template: ${error instanceof Error ? error.message : 'Unknown error'}`, error instanceof Error ? { cause: error } : undefined);
    }
});
export const generateOutput = (rootDirs_1, config_1, processedFiles_1, allFilePaths_1, ...args_1) => __awaiter(void 0, [rootDirs_1, config_1, processedFiles_1, allFilePaths_1, ...args_1], void 0, function* (rootDirs, config, processedFiles, allFilePaths, gitDiffResult = undefined, gitLogResult = undefined, deps = {
    buildOutputGeneratorContext,
    generateHandlebarOutput,
    generateParsableXmlOutput,
    generateParsableJsonOutput,
    sortOutputFiles,
}) {
    // Sort processed files by git change count if enabled
    const sortedProcessedFiles = yield deps.sortOutputFiles(processedFiles, config);
    const outputGeneratorContext = yield deps.buildOutputGeneratorContext(rootDirs, config, allFilePaths, sortedProcessedFiles, gitDiffResult, gitLogResult);
    const renderContext = createRenderContext(outputGeneratorContext);
    switch (config.output.style) {
        case 'xml':
            return config.output.parsableStyle
                ? deps.generateParsableXmlOutput(renderContext)
                : deps.generateHandlebarOutput(config, renderContext, sortedProcessedFiles);
        case 'json':
            return deps.generateParsableJsonOutput(renderContext);
        case 'markdown':
        case 'plain':
            return deps.generateHandlebarOutput(config, renderContext, sortedProcessedFiles);
        default:
            throw new RepomixError(`Unsupported output style: ${config.output.style}`);
    }
});
export const buildOutputGeneratorContext = (rootDirs_1, config_1, allFilePaths_1, processedFiles_1, ...args_1) => __awaiter(void 0, [rootDirs_1, config_1, allFilePaths_1, processedFiles_1, ...args_1], void 0, function* (rootDirs, config, allFilePaths, processedFiles, gitDiffResult = undefined, gitLogResult = undefined) {
    let repositoryInstruction = '';
    if (config.output.instructionFilePath) {
        const instructionPath = path.resolve(config.cwd, config.output.instructionFilePath);
        try {
            repositoryInstruction = yield fs.readFile(instructionPath, 'utf-8');
        }
        catch (_a) {
            throw new RepomixError(`Instruction file not found at ${instructionPath}`);
        }
    }
    let emptyDirPaths = [];
    if (config.output.includeEmptyDirectories) {
        try {
            emptyDirPaths = (yield Promise.all(rootDirs.map((rootDir) => searchFiles(rootDir, config)))).reduce((acc, curr) => ({
                filePaths: [...acc.filePaths, ...curr.filePaths],
                emptyDirPaths: [...acc.emptyDirPaths, ...curr.emptyDirPaths],
            }), { filePaths: [], emptyDirPaths: [] }).emptyDirPaths;
        }
        catch (error) {
            if (error instanceof Error) {
                throw new RepomixError(`Failed to search for empty directories: ${error.message}`);
            }
        }
    }
    return {
        generationDate: new Date().toISOString(),
        treeString: generateTreeString(allFilePaths, emptyDirPaths),
        processedFiles,
        config,
        instruction: repositoryInstruction,
        gitDiffResult,
        gitLogResult,
    };
});
//# sourceMappingURL=outputGenerate.js.map